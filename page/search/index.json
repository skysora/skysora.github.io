[{"content":"AssembleSIC和AssembleSIC/XE版本差別 多四個暫存器，圖1 從一個指令格式變成四個指令格式，圖2 取值模式ni，圖3 ni 10跟01不存在x pc、b、e任兩個不會同時為1，在ni不是11時，反之是11時，可與x同時存在。圖4 SIC版本所有數字都要宣告，反之圖5 詳細請參閱教學 AssembleSIC 主程式 Github Step1:製作編碼對應表 Step2:將對應位置Label、operationCode、operand存入變數中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 while(getline(input,str)){ flag=0; if(str==\u0026#34; \u0026#34;||str[0]==\u0026#39;.\u0026#39;){ continue; } flag=0; int a = str.length(); if(searchMarker(str,0)\u0026lt;=str.length()){ lable[i] = str.substr(0,7);//(position,lenght) }if((flag!=1) \u0026amp;\u0026amp; (searchMarker(str,8)\u0026lt;=str.length())){ operationCode[i] = str.substr(8,8); }if((flag!=1) \u0026amp;\u0026amp; (searchMarker(str,16)\u0026lt;=str.length())){ operand[i] = str.substr(16,8); }else{ operand[i] = \u0026#34;\u0026#34;; } deleteMark(lable[i]); deleteMark(operationCode[i]); deleteMark(operand[i]); iter = table.find(operationCode[i].c_str()); if(iter==table.end()){ errorMessage[i] = operationCode[i]; } printf(\u0026#34;%-5d%-8s%-8s%-8s\\n\u0026#34;,i,lable[i].c_str(),operationCode[i].c_str(),operand[i].c_str()); i++; } - Step3:計算location和location內的內容，location內的內容還未完整 因為有些變數在後面宣告所以要先跑一遍所有指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 for(j = start;j\u0026lt;=length;j++) { if(!errorMessage.empty()){ printf(\u0026#34;Error!!\\n\u0026#34;); for(errorMessageIter = errorMessage.begin();errorMessageIter!=errorMessage.end();errorMessageIter++){ printf(\u0026#34;%-2d %-8s\\n\u0026#34;,errorMessageIter-\u0026gt;first,errorMessageIter-\u0026gt;second.c_str()); } return 0; }else{ obj[j] = searchMap(operationCode[j]); // 不會生成機器碼的走這裡 if(!table[operationCode[j].c_str()].first.compare(\u0026#34;NULL\u0026#34;)){//actual location if(!operationCode[j].compare(\u0026#34;RESW\u0026#34;)){ //RESW表示我們要定義一個字（word）型數據，並分配儲存空間。 addition =hexadecimalConvertDecimal(location[j]) + atoi(operand[j].c_str())*3; location[j+1] = decimalConvertHexadecimal(addition); //RESB 表示我們要定義一個位元組（byte）型數據，並分配儲存空間。 }else if(!operationCode[j].compare(\u0026#34;RESB\u0026#34;)){ addition =hexadecimalConvertDecimal(location[j]) + atoi(operand[j].c_str()); location[j+1] = decimalConvertHexadecimal(addition); }else{ location[j+1] = location[j]; } }else{ // operationCode[j]等於\u0026#34;BYTE\u0026#34;，則compare函數將傳回值0 if(!operationCode[j].compare(\u0026#34;BYTE\u0026#34;)){ //字元型數據 if(operand[j][0]==\u0026#39;C\u0026#39;){ //減三個字元，像是C\u0026#39;\u0026#39; addition = hexadecimalConvertDecimal(location[j]) + (operand[j].length()-3); location[j+1] = decimalConvertHexadecimal(addition); }else{ //表示16進制 addition = hexadecimalConvertDecimal(location[j]) + (operand[j].length()-3)/2; location[j+1] = decimalConvertHexadecimal(addition); } }else{ addition = hexadecimalConvertDecimal(location[j]) + table[operationCode[j].c_str()].second; location[j+1] = decimalConvertHexadecimal(addition); } } //沒有Label的加入table if(!lable[j].empty()){ symbolTable[lable[j].c_str()] = make_pair(j,location[j].c_str()); } printf(\u0026#34;%-2d%-8s%-10s%-8s%-8s\\n\u0026#34;,j,operationCode[j].c_str(),operand[j].c_str(),obj[j].c_str(),location[j].c_str()); } } - Step4:補充完location內的內容，產生S、Ｔ、E卡內容 S卡（Start Card）：\n用途：S卡用於指定程式的起始位址。 格式：S卡的格式通常為 S,起始位址。 範例：S,0040 表示程式從位址 0040 開始執行。 T卡（Text Card）：\n用途：T卡用於包含程式的目標代碼指令或資料。 格式：T卡的格式通常包括起始位址、長度和目標碼欄位。 範例：T,0040,0014,2F4D2F4F2F54\u0026hellip; 表示從位址 0040 開始的程式碼，長度為 0014 位元組，包含一系列目標程式碼。 E卡（End Card）：\n用途：E卡用於指定程式的終止位址，即程式的結束。 格式：E卡的格式通常為 E,終止位址。 範例：E,007C 表示程式在位址 007C 結束執行。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 for(j = start;j\u0026lt;=length;j++) { if(!errorMessage.empty()){ return 0; }else{ // 用於產生程式的起始卡（Start Card） if(!operationCode[j].compare(\u0026#34;START\u0026#34;)){ Scard.append(\u0026#34;S,\u0026#34;); Scard.append(operationCode[j].c_str()); Scard.append(\u0026#34;,\u0026#34;); Scard.append(lable[j].c_str()); Scard.append(\u0026#34;,\u0026#34;); int a = hexadecimalConvertDecimal(location[length].c_str()); int b = hexadecimalConvertDecimal(location[j].c_str()); Scard.append(decimalConvertHexadecimal(a-b)); // cout\u0026lt;\u0026lt;Scard\u0026lt;\u0026lt;endl; } // 用於產生程式的結束卡（End Card） if(!operationCode[j].compare(\u0026#34;END\u0026#34;)){ Ecard.append(\u0026#34;E,\u0026#34;); Ecard = Ecard + symbolTable[operand[j].c_str()].second; // cout\u0026lt;\u0026lt;Ecard\u0026lt;\u0026lt;endl; } // 不在table的operationCode沒有機器碼 if(!table[operationCode[j].c_str()].first.compare(\u0026#34;NULL\u0026#34;)){ obj[j] = \u0026#34;\u0026#34;; //若 symbolTable.find(operand[j].c_str()) 找到了匹配的键，則回傳true }else if(symbolTable.find(operand[j].c_str()) != symbolTable.end()){ obj[j].append(symbolTable[operand[j].c_str()].second,0,4); // printf(\u0026#34;%-8s %-8s\\n\u0026#34;,lable[j].c_str(),obj[j].c_str()); //算位元編碼 }else if(!operationCode[j].compare(\u0026#34;BYTE\u0026#34;)){ obj[j] = \u0026#34;\u0026#34;; if(operand[j][0]==\u0026#39;C\u0026#39;){ for(int i=2;i\u0026lt;operand[j].length()-1;i++){ int oper = operand[j][i]; str = decimalConvertHexadecimal(oper); while(str[0]==\u0026#39;0\u0026#39;){ str.erase(0,1); } obj[j] = obj[j]+str; } }else{ obj[j] = obj[j].append(operand[j],2,operand[j].length()-3); } //RSUB：這是一個彙編指令，表示“Return from SUBroutine”，意思是從子程式返回。 }else if(!operand[j].compare(\u0026#34;RSUB\u0026#34;)){ //如果是其中之一，表示找到了跳躍或比較的指令。 for(i=j;;i--){ if(operationCode[i].compare(\u0026#34;JSUB\u0026#34;) == 0 || operationCode[i].compare(\u0026#34;J\u0026#34;)==0 || operationCode[i].compare(\u0026#34;COMP\u0026#34;)==0){ break; } } obj[j].append(location[i].c_str(),0,4); }else if(operand[j].find(\u0026#34;,X\u0026#34;)!=-1){ int xPosition = operand[j].find(\u0026#34;,X\u0026#34;); temp = operand[j].substr(0,xPosition); printf(\u0026#34;%s\\n\u0026#34;,temp.c_str()); obj[j].append(symbolTable[temp].second,0,4); //它的目的是將字串 obj[j] 中的某個字元位置的十六進位值加上 8。*這裡不太確定 obj[j] = covertHexadecimal(obj[j],8,2); }else{ obj[j].append(location[j].c_str(),0,4); } // ---------------------------------------- objLength+=obj[j].length(); //T卡是一種用於表示程式目標程式碼的文字格式，通常由位址、指令或資料以及其他相關資訊組成。 if(obj[j].length() == 0){//creat Tcard if(objLength\u0026gt;0){ Tcard[k] = creatTcard(objLength,j-1,obj,location,start++); start = j+1; k++; objLength=0; }else{ start++; continue; } }else if(objLength\u0026gt;=30 || obj[j].length()!=6){ Tcard[k] = creatTcard(objLength,j,obj,location,start); // printf(\u0026#34;Tcard %d:%s\\n\u0026#34;,k,Tcard[k].c_str()); start = j+1; k++; objLength=0; } } // printf(\u0026#34;%-2d%-8s%-10s%-8s%-8s\\n\u0026#34;,j,operationCode[j].c_str(),operand[j].c_str(),obj[j].c_str(),location[j].c_str()); } - 副程式 searchMarker 搜尋空白字元，並回傳該字元出現的第一個位置 以position作為切割點切割a並往前搜尋空白字元位置回傳 1 2 3 4 5 6 7 8 9 int searchMarker(string a,int position){ if(a.find(\u0026#39; \u0026#39;,position)!=-1){ return a.find(\u0026#39; \u0026#39;,position); }else{ flag = 1; return a.length(); } } - deleteMark 刪除多餘的字元 1 2 3 4 void deleteMark(string \u0026amp;str){ str.erase(std::remove(str.begin(), str.end(), \u0026#39; \u0026#39;), str.end()); str.erase(std::remove(str.begin(), str.end(), \u0026#39;\\r\u0026#39;), str.end()); } searchMap 搜隊table中對應的編碼 1 2 3 4 5 6 7 8 9 10 string searchMap(string a){ for(iter=table.begin();iter!= table.end();iter++){ //cout\u0026lt;\u0026lt;iter-\u0026gt;first\u0026lt;\u0026lt;iter-\u0026gt;second\u0026lt;\u0026lt;endl; if(strcompare(a,iter-\u0026gt;first)==1){ return iter-\u0026gt;second.first; } } return \u0026#34;null\u0026#34;; } - covertHexadecimal 將一個十六進位數字字串進行加法運算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 string covertHexadecimal(string a,int addition,int position){ int number; //printf(\u0026#34;a[position]:%d\\n\u0026#34;,a[position]); if(a[position]\u0026gt;64){ number = a[position]-55; }else{ number = a[position]-48; } number+=addition; //printf(\u0026#34;number:%d\\n\u0026#34;,number); if(number\u0026lt;0){ a = covertHexadecimal(a,-1,position-1); a = covertHexadecimal(a,addition+16,position); }else if(number\u0026lt;10 \u0026amp;\u0026amp; number\u0026gt;=0){ a[position] = number+48; }else if(number\u0026gt;9\u0026amp;\u0026amp;number\u0026lt;16){ a[position] = number+55; }else{ int carry = number/16; number = number%16; a = covertHexadecimal(a,carry,position-1); a[position] = number+48; } return a; } - AssembleXE 主程式 Github Step1:製作編碼對應表 掃第一遍計算location 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 for line in file.readlines(): data.append(Row(\u0026#34;0\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;)) if(line[0]==\u0026#34;.\u0026#34;): continue data[i].label = line[0:7].replace(\u0026#34; \u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;\\n\u0026#34;,\u0026#34;\u0026#34;) data[i].code = line[7:15].replace(\u0026#34; \u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;\\n\u0026#34;,\u0026#34;\u0026#34;) data[i].value = line[15:35].replace(\u0026#34; \u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;\\n\u0026#34;,\u0026#34;\u0026#34;) #------------------------------------------------------------------------------------------------------ #如果遇到要換區塊換區塊 flag,BLOCK = data[i].decideCode(BLOCK,data[i-1]) #------------------------------------------------------------------------------------------------------ #LITTAB是一個用於儲存文字文字表（Literal Table）的資料結構或字典。 文字文字表通常用於儲存程式中的文字常數，並為它們指派一個唯一的識別碼。 #計算字元or數值的ASCII if(data[i].value!=\u0026#34;\u0026#34; and str(data[i].value)[0] == \u0026#39;=\u0026#39;): if (data[i].value[1]==\u0026#39;C\u0026#39;): temp = binascii.b2a_hex(str(data[i].value[3:len(data[i].value)-1]).encode(\u0026#39;utf-8\u0026#39;)) a = len(data[i].value)-4 else: temp = str(data[i].value[3:len(data[i].value)-1]) a = (len(data[i].value)-4)/2 LITTAB[str(LITTAB_number)] = [str(data[i].value[1:]),temp,a,data[i].loc] # print(LITTAB) LITTAB_number = LITTAB_number + 1 #------------------------------------------------------------------------------------------------------ # 若不為虛擬指令執行這裡，現在位置+上指令容量 if(data[i].code != \u0026#34;END\u0026#34; and data[i].code != \u0026#34;ORG\u0026#34; and data[i].code != \u0026#34;LTORG\u0026#34; and data[i].code != \u0026#34;BASE\u0026#34;): # \u0026#34;+\u0026#34; 開頭，表示這是擴充格式的指令。 # flag為本行指令location if(data[i].code[0] == \u0026#34;+\u0026#34;): # data[i].code)[1::]為去除+好的code data[i+1].loc = \u0026#39;{0:x}\u0026#39;.format(int(str(flag),16) + int(1) + int(add(data[i].code[1::],data[i].value,codeDict[str(data[i].code)[1::]][1]))) else: if(data[i].code == \u0026#34;USE\u0026#34;): data[i].loc = \u0026#34;NULL\u0026#34; data[i].block = \u0026#34;NULL\u0026#34; # print(str(flag) + \u0026#34;+\u0026#34; + str(add(data[i].code,data[i].value,codeDict[str(data[i].code)][1]))) data[i+1].loc = \u0026#39;{0:x}\u0026#39;.format(int(str(flag),16) + int(add(data[i].code,data[i].value,codeDict[str(data[i].code)][1]))) # ------------------------------------------------------------------------------------------------------ # BASE 指令的作用是告訴組譯器或組譯器，在後續的指令中，使用 operand 指定的位址作為基底位址來計算相對位址。 這樣可以減少在程式中手動計算相對位址的複雜性。 elif(data[i].code == \u0026#34;BASE\u0026#34;): BASETABLE[str(i)] = [BLOCK,data[i].loc,data[i].value] data[i+1].loc = data[i].loc data[i+1].block = data[i].block elif(data[i].code ==\u0026#34;ORG\u0026#34;): # 那麼意味著 ORG 指令是無操作的，它只是用來標記當前位置。 在這種情況下，data[i+1] 的 loc 和 block 屬性被設定為先前儲存的 org 物件的 loc 和 block 屬性的值，以恢復先前的位置。 if(data[i].value == \u0026#34;*\u0026#34;): data[i+1].loc = org.loc data[i+1].block = org.block # 則表示 ORG 指令要求程式跳到一個新的位址。 decideOperation 函數可能被用來計算新位址的值 else: value,decideRelative = decideOperation(data[i].value) data[i+1].loc = \u0026#39;{0:x}\u0026#39;.format(int(value)) data[i+1].block = BLOCK org.loc = data[i].loc org.block = data[i].block data[i].loc = \u0026#34;NULL\u0026#34; data[i].block = \u0026#34;NULL\u0026#34; #------------------------------------------------------------------------------------------------------ elif(data[i].code == \u0026#34;LTORG\u0026#34; or data[i].code == \u0026#34;END\u0026#34;): if(data[i].code ==\u0026#34;LTORG\u0026#34;): data[i+1].loc = data[i].loc # 程式結束後新增宣告 for j,k in enumerate(LITTAB): i = i + 1 data[i].label = \u0026#34;*\u0026#34; data[i].block = data[i-1].block data[i].code = \u0026#34;*\u0026#34; data[i].value = \u0026#34;=\u0026#34; + str(LITTAB[str(k)][0]) data[i+1].loc = \u0026#39;{0:x}\u0026#39;.format(int(str(data[i].loc),16) + int(LITTAB[str(k)][2])) SYMBOLTABLE[data[i].value] = [i,data[i].block,data[i].loc] # print(\u0026#39;%-2s %-4s %-8s %-8s %-8s %-15s %-8s\u0026#39; % (i,str(data[i].loc).zfill(4),data[i].block,data[i].label,data[i].code,data[i].value,data[i].obj)) LITTAB = {} else: print(\u0026#34;talk\u0026#34;) #------------------------------------------------------------------------------------------------------ #紀錄Label if(data[i].label != \u0026#34;\u0026#34;): if(data[i].code == \u0026#34;EQU\u0026#34; and data[i].value != \u0026#34;*\u0026#34;): value,decideRelative = decideOperation(data[i].value) if(decideRelative%2==0): data[i].block = \u0026#34;NULL\u0026#34; EQUTABLE[data[i].label] = [i,BLOCK,value] SYMBOLTABLE[data[i].label] = [i,BLOCK,value] # print(EQUTABLE) else: SYMBOLTABLE[data[i].label] = [i,BLOCK,data[i].loc] #------------------------------------------------------------------------------------------------------ # print(\u0026#39;%-2s %-4s %-8s %-8s %-8s %-15s %-8s\u0026#39; % (i,str(data[i].loc).zfill(4),data[i].block,data[i].label,data[i].code,data[i].value,data[i].obj)) i = i + 1 length = i ProgramBlockTable = {\u0026#34;default\u0026#34;:[0,\u0026#34;0\u0026#34;,ProgramEnd[0]], \u0026#34;CDATA\u0026#34;:[1,ProgramEnd[0],ProgramEnd[1]], \u0026#34;CBLKS\u0026#34;:[2,\u0026#39;{0:x}\u0026#39;.format((int(str(ProgramEnd[0]),16) + int(str(ProgramEnd[1]),16))),ProgramEnd[2]]} #-------------------------------------------------------------------------------------------------------------------------- for i,k in enumerate(SYMBOLTABLE): if(k in EQUTABLE): SYMBOLTABLE[k][1] = 0 # -------------------------------------------------------------------------------------------------------------- 掃第二遍計算obj，並建立卡片 H卡（Header Card）：H卡是目標程式檔案的頭卡，用於提供有關程式的基本信息，如程式名稱、程式起始位址、程式長度等。 在給定的程式碼中，H = \u0026quot;\u0026quot; 似乎表示沒有H卡資訊。\nT卡（Text Card）：T卡包含了程式的機器指令以及它們在記憶體中的位址資訊。 T卡由一個起始位址和一系列的機器指令組成，每個指令通常以一個十六進位數表示。 在給定的程式碼中，T = [] 可能表示目標程式不包含T卡資訊或T卡為空。\nM卡（Modification Card）：M卡用於指示需要在程式載入時對記憶體中的資料進行修改的資訊。 這可以用來支援程式的重定位。 在給定的程式碼中，M = [] 可能表示沒有M卡資訊或M卡為空。\nE卡（End Card）：E卡用來標示目標程式的結束，包含程式的入口點位址。 在給定的代碼中，E = [] 可能表示沒有E卡資訊或E卡為空。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 H = \u0026#34;\u0026#34; T = [] M = [] E = [] number = 0 count = 0 TcardNumber = 0 for i,k in enumerate(data): Extend = 0 #------------------------------------------------------------------------------------------------------ if(i == length): break if(k.code == \u0026#34;START\u0026#34;): H = \u0026#34;H,\u0026#34;+ str(k.label) +\u0026#34;,\u0026#34;+ str(k.loc).zfill(4) + \u0026#34;,\u0026#34;+str(\u0026#39;{0:x}\u0026#39;.format(int(str(ProgramEnd[0]),16) + int(str(ProgramEnd[1]),16) + int(str(ProgramEnd[1]),16))) k.obj = \u0026#34;NULL\u0026#34; # print(\u0026#39;%-2s %-4s %-8s %-8s %-8s %-8s %-15s %-8s\u0026#39; % (i,str(k.loc).zfill(4),k.block,correctPosition(k.block,k.loc).zfill(4),k.label,k.code,k.value,k.obj)) continue elif(k.code == \u0026#34;END\u0026#34;): E = \u0026#34;E,\u0026#34; + str(k.value) elif(k.code == \u0026#34;USE\u0026#34; or k.code == \u0026#34;RESW\u0026#34; or k.code == \u0026#34;EQU\u0026#34; or k.code == \u0026#34;LTORG\u0026#34; or k.code == \u0026#34;ORG\u0026#34; or k.code == \u0026#34;BASE\u0026#34;): k.obj = \u0026#34;NULL\u0026#34; elif(k.code == \u0026#34;COMPR\u0026#34;): behind = str(codeDict[str(k.code)][0]) k.obj = behind + str(LEETTERTABLE[str(k.value[0])]) + str(LEETTERTABLE[str(k.value[len(k.value)-1])]) elif(k.code == \u0026#34;CLEAR\u0026#34;): behind = str(codeDict[str(k.code)][0]) k.obj = behind + str(LEETTERTABLE[str(k.value)]) + \u0026#34;0\u0026#34; elif(k.code == \u0026#34;RSUB\u0026#34;): k.obj = str(codeDict[str(k.code)][0]) + \u0026#34;0000\u0026#34; elif(k.value == \u0026#34;\u0026#34;): k.obj = \u0026#34;000000\u0026#34; elif(k.code == \u0026#34;RESB\u0026#34;): k.obj = \u0026#34;NULL\u0026#34; elif(k.code == \u0026#34;BYTE\u0026#34;): if(k.value[0] == \u0026#39;C\u0026#39;): k.obj = binascii.b2a_hex(str(data[i].value[3:len(data[i].value)-1]).encode(\u0026#39;utf-8\u0026#39;)) else: k.obj = k.value[2:len(k.value)-1] elif(k.value[0] == \u0026#34;#\u0026#34; or k.value[0] == \u0026#34;@\u0026#34; or k.code[0] == \u0026#34;+\u0026#34; or k.value in SYMBOLTABLE or k.value[0:len(k.value)-2] in SYMBOLTABLE): #如果value是在SYMBOLTABLE裡 if(k.value in SYMBOLTABLE or k.value[1::] in SYMBOLTABLE or k.value[0:len(k.value)-2] in SYMBOLTABLE): #------------------------------------------------------------------------------------------------------ if(k.value[1::] in SYMBOLTABLE): NOW = correctPosition(SYMBOLTABLE[k.value[1::]][1],SYMBOLTABLE[k.value[1::]][2]) Mcard = \u0026#34;M,\u0026#34; + str(k.loc).zfill(6) + \u0026#34;,+\u0026#34; + str(k.value[1::]) elif(k.value[0:len(k.value)-2] in SYMBOLTABLE): NOW = correctPosition(SYMBOLTABLE[k.value[0:len(k.value)-2]][1],SYMBOLTABLE[k.value[0:len(k.value)-2]][2]) Mcard = \u0026#34;M,\u0026#34; + str(k.loc).zfill(6) + \u0026#34;,+\u0026#34; + str(k.value[0:len(k.value)-2]) elif(k.value in SYMBOLTABLE): NOW = correctPosition(SYMBOLTABLE[k.value][1],SYMBOLTABLE[k.value][2]) if(k.code != \u0026#34;*\u0026#34;): Mcard = \u0026#34;M,\u0026#34; + str(k.loc).zfill(6) + \u0026#34;,+\u0026#34; + str(k.value) M.append(Mcard) #====================================================================================================== if(k.code[0] == \u0026#34;+\u0026#34;):#有加號 behind = str(codeDict[str(k.code[1::])][0]) + \u0026#34;00\u0026#34; else: behind = str(codeDict[str(k.code)][0]) #====================================================================================================== if(data[i].code[0] != \u0026#34;+\u0026#34;): PC = \u0026#39;{0:x}\u0026#39;.format((int(str(correctPosition(data[i].block,data[i].loc)),16)) + int(add(data[i].code,data[i].value,codeDict[str(data[i].code)][1]))) else:#沒有+號後面是label PC = \u0026#39;{0:x}\u0026#39;.format((int(str(correctPosition(data[i].block,data[i].loc)),16)) + int(1) + int(add(data[i].code[1::],data[i].value,codeDict[str(data[i].code[1::])][1]))) # print(\u0026#34;behind:\u0026#34; + str(behind)) # print(\u0026#34;Now:\u0026#34; + str(behind)) #------------------------------------------------------------------------------------------------------ if(k.code[0] == \u0026#34;+\u0026#34; and k.value[1::] in SYMBOLTABLE):#+號後面是字符直接放 k.obj = behind +str(correctPosition(SYMBOLTABLE[k.value[1::]][1],SYMBOLTABLE[k.value[1::]][2])) elif(k.code[0] == \u0026#34;+\u0026#34; and k.value in SYMBOLTABLE):#+號後面是字符直接放 k.obj = behind +str(correctPosition(SYMBOLTABLE[k.value][1],SYMBOLTABLE[k.value][2])) elif( (int(str(NOW),16)-int(str(PC),16) \u0026gt; 1000 or int(str(NOW),16)-int(str(PC),16) \u0026lt; -1000) and Extend == 0): small = i flag = 0 for n,m in enumerate(BASETABLE): # print(closedBasePosition) if(flag==0): closedBasePosition = m flag = 1 if(int(closedBasePosition) - i \u0026lt; small): closedBasePosition = m if(BASETABLE[str(closedBasePosition)][2] in SYMBOLTABLE): BASE = correctPosition(SYMBOLTABLE[BASETABLE[str(closedBasePosition)][2]][1],SYMBOLTABLE[BASETABLE[str(closedBasePosition)][2]][2]) else: BASE = BASETABLE[str(closedBasePosition)][2] temp = \u0026#34;BASE\u0026#34; # print(NOW) # print(BASE) k.obj = behind + SUB(int(str(NOW),16),int(str(BASE),16),0) else: # print(NOW) # print(PC) temp = \u0026#34;PC\u0026#34; if(k.code[0] == \u0026#34;+\u0026#34;): k.obj = behind + SUB(int(str(NOW),16),int(str(PC),16),1) else: k.obj = behind + SUB(int(str(NOW),16),int(str(PC),16),0) else:#如果value是數字 if(k.code[0] == \u0026#34;+\u0026#34;): behind = str(codeDict[str(k.code[1::])][0]) + \u0026#34;00\u0026#34; k.obj = behind + \u0026#39;{0:x}\u0026#39;.format(int(k.value[1::])) else: k.obj = str(codeDict[str(k.code)][0]) + str(int(str(k.value[1::]),16)).zfill(4) # print(k.obj) k = symbol(k,temp) k.obj = str(k.obj).zfill(6) #------------------------------------------------------------------------------------------------------ elif(k.value[0] == \u0026#34;=\u0026#34;): NOW = correctPosition(SYMBOLTABLE[k.value[1:len(k.value)]][1],SYMBOLTABLE[k.value[1:len(k.value)]][2]) PC = \u0026#39;{0:x}\u0026#39;.format((int(str(correctPosition(data[i].block,data[i].loc)),16)) + int(add(data[i].code[1::],data[i].value,codeDict[str(data[i].code[1::])][1]))) behind = str(codeDict[str(k.code)][0]) k.obj = behind + str(SUB(int(str(NOW),16),int(str(PC),16))).zfill(4) else: behind = str(codeDict[str(k.code)][0]) if(k.value in LEETTERTABLE): k.obj = behind + str(LEETTERTABLE[k.value]).zfill(2) else: k.obj = behind + \u0026#34;0000\u0026#34; #------------------------------------------------------------------------------------------------------ print(\u0026#39;%-2s %-4s %-8s %-8s %-8s %-8s %-15s %-8s\u0026#39; % (i,str.upper(str(k.loc)).zfill(4),k.block,str.upper(str(correctPosition(k.block,k.loc).zfill(4))),k.label,k.code,k.value,str.upper(str(k.obj)))) # print(ProgramBlockTable) for i,k in enumerate(data): if(k.obj != \u0026#34;NULL\u0026#34;): count = count + len(k.obj) TcardNumber = TcardNumber + 1 if(count+len(data[i+1].obj)\u0026gt;30 or data[i+1].obj == \u0026#34;NULL\u0026#34; or data[i+1].code == \u0026#34;END\u0026#34;): Tposition = i-TcardNumber+1 # print(\u0026#34;Tposition:\u0026#34; + str(Tposition)) Tcard = \u0026#34;T,\u0026#34; + str(correctPosition(data[Tposition].block,data[Tposition].loc)).zfill(6) + \u0026#34;,\u0026#34; + str(\u0026#39;{0:x}\u0026#39;.format(int(count))) for j in range(i-TcardNumber+1,i+1): Tcard = Tcard + \u0026#34;,\u0026#34; +str(data[j].obj) # print(Tcard) T.append(Tcard) TcardNumber = 0 count = 0 if(k.code == \u0026#34;END\u0026#34;): break if os.path.exists(\u0026#34;card.txt\u0026#34;): os.remove(\u0026#34;card.txt\u0026#34;) a = open(\u0026#34;card.txt\u0026#34;, \u0026#39;w\u0026#39;) a.writelines(str(H)) a.writelines(\u0026#34;\\n\u0026#34;) for i in range(len(T)): a.writelines(T[i]) a.writelines(\u0026#34;\\n\u0026#34;) a.writelines(E) a.close() if os.path.exists(\u0026#34;list.txt\u0026#34;): os.remove(\u0026#34;list.txt\u0026#34;) file_write_obj = open(\u0026#34;list.txt\u0026#34;, \u0026#39;w\u0026#39;) for i,k in enumerate(data): #index file_write_obj.writelines(\u0026#39;%-4s\u0026#39; %i) #location if(k.loc == \u0026#34;NULL\u0026#34;): file_write_obj.writelines(\u0026#34;%-6s\u0026#34; %(\u0026#34; \u0026#34;)) else: file_write_obj.writelines(\u0026#39;%-6s\u0026#39; %str(k.loc).zfill(4)) #block if(k.block == \u0026#34;NULL\u0026#34;): file_write_obj.writelines(\u0026#34;%-3s\u0026#34; %(\u0026#34; \u0026#34;)) else: file_write_obj.writelines(\u0026#39;%-3s\u0026#39; %k.block) #correctPosition if(k.block == \u0026#34;NULL\u0026#34;): file_write_obj.writelines(\u0026#34;%-8s\u0026#34; %(\u0026#34; \u0026#34;)) else: file_write_obj.writelines(\u0026#39;%-8s\u0026#39; %str.upper(str(correctPosition(k.block,k.loc).zfill(4)))) #label,code,value file_write_obj.writelines(\u0026#39;%-8s%-8s%-15s\u0026#39; %(k.label,k.code,str(k.value))) #object code if(k.obj == \u0026#34;NULL\u0026#34;): file_write_obj.writelines(\u0026#34;%-8s\u0026#34; %(\u0026#34; \u0026#34;)) else: file_write_obj.writelines(\u0026#39;%-8s\u0026#39; %(str.upper(str(k.obj)))) # print(\u0026#39;%-2s %-4s %-8s %-8s %-8s %-8s %-15s %-8s\u0026#39; % (i,str(k.loc).zfill(4),k.block,correctPosition(k.block,k.loc).zfill(4),k.label,k.code,k.value,k.obj)) file_write_obj.write(\u0026#39;\\n\u0026#39;) if(k.code == \u0026#34;END\u0026#34;): break file_write_obj.close() print(\u0026#34;Success\u0026#34;) 副程式 宣告Row Class Row Class 負責儲存每行指令 decideCode:如果遇到要換區塊指令則要換區塊 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Row(): def __init__(self,loc,block,label,code,value,obj): self.loc = loc self.block = block self.label = label self.code = code self.value = value self.obj = obj def decideCode(self,block,previous):#決定program block 的位置和值 #flag是要記錄上一個的值，如果有use要特別取ProgramEnd的紀錄值 ProgramEnd[block] = self.loc if(self.code ==\u0026#34;USE\u0026#34;): # print(str(block) + \u0026#34; \u0026#34; + str(self.code) + \u0026#34; \u0026#34; + str(self.value) + \u0026#34; \u0026#34; + str(ProgramEnd[block])) if(self.value == \u0026#34;CDATA\u0026#34;): self.block = 1 elif(self.value == \u0026#34;CBLKS\u0026#34;): self.block = 2 else: self.block = 0 self.loc = ProgramEnd[self.block] flag = ProgramEnd[self.block] else: flag = self.loc self.block = block return flag,self.block - ","date":"2023-11-11T18:45:18+08:00","image":"http://skysora.github.io/post/9/header_hudd2e8259c20ed0dcaa856c253552e90f_14625_120x120_fill_q75_box_smart1.jpg","permalink":"http://skysora.github.io/post/9/","title":"[複習]AssembleSIC和AssembleXE"},{"content":"Bitwise Operation Bitwise Left Shift(\u0026laquo;) Bitwise Right Shift(\u0026raquo;) 1 2 3 0001 \u0026lt;\u0026lt; 1 = 0010 1000 \u0026gt;\u0026gt; 1 = 0100 - AND(\u0026amp;) 1 2 3 4 5 0 \u0026amp; 0 = 0 0 \u0026amp; 1 = 0 1 \u0026amp; 0 = 0 1 \u0026amp; 1 = 1 - or(|) 1 2 3 4 5 0 | 0 = 0 0 | 1 = 1 1 | 0 = 1 1 | 1 = 1 - xor(^) 1 2 3 4 5 0 ^ 0 = 0 0 ^ 1 = 1 1 ^ 0 = 1 1 ^ 1 = 0 - not(~) 1 2 3 ~ 0 = 1 ~ 1 = 0 - Link List \u0026amp; Array array: 會分配『連續』的記憶體空間給予陣列存放資料。 1 2 int x[5] = {1,2,3,4,5}; - stack: 後進先出 queue: 先進先出 Link List \u0026amp; Array 差別 功能 Link List Array 記憶體 不需要連續的空間 需要連續的空間 節點型態 各node形態不相同 各node形態相同 操作複雜度 插入、刪除都為O(n) 插入刪除都為O(1) 空間配置 不需預留空間 須事先宣告連續空間 資料分割、連結 容易 不容易 存取方式 只能循序存取 可支援隨機與循序存取 存取速度 速度慢 速度快 可靠性 差 佳 額外指標空間 需要額外的指標空間 不需要 Pointer 指標：某變數的位置。 指標變數：用來存放指標的變數。 代表取值 \u0026amp; 代表取記憶體位置 題目 Q1: 給一個int a[20]已排序的陣列，請寫一個function(a, size)能印出0~500的數字，且不包含a陣列內的元素，請用最少的時間和空間複雜度完成。\nAns:\n1 2 3 4 5 6 7 8 9 10 11 void function(int* a, int size){ int* ptr = a; for (int i = 0; i \u0026lt;= 500; i++) { if (*ptr == i) ptr++; else printf(\u0026#34;%d\u0026#34;, i); } } - Q2: 給一個int a[20]已排序的陣列，請寫一個function(a, size, b)能依照參數b(b = 0~4)別印出該區間的數字，且不包含a陣列內的元素，例如：\n1 2 3 4 5 b = 0, 印出0~99 b = 1, 印出100~199 ... - Ans:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void function(int *a, int size, int b){ int *ptr = a; int i; while (*ptr \u0026lt; b * 100) { ptr++; } for (i = b*100; i\u0026lt;(b+1)*100; i++) { if (*ptr == i) ptr++; else printf(\u0026#34;%d\\n\u0026#34;, i); } } - Q3: 情境題，給予一個 structure\n1 2 3 4 5 6 7 8 9 struct ListStruct{ unsigned int DataH; unsigned int DataL; unsigned int NextPtr; }; struct ListStruct ListArray[1000]; #define NULL 0xFFFF unsigned int ListHead = 0; - 其中有兩個條件\n條件一: ListArray[Entry1].NextPtr = ListArray[Entry2] 條件二: ListArray[Entry2].DataH \u0026laquo; 16 + ListArray[Entry2].DataL \u0026gt; ListArray[Entry1].DataH \u0026laquo; 16 + ListArray[Entry1].DataL 代表\n第一個 index 中的 NextPtr 會指到另一個 index 中的起始位址 另一個 index 中的起始位址的資料內容大小一定大於原起始資料的大小 請寫一個function(unsigned int DATA_A, unsigned int DATA_B)， 能在ListArray中找到符合ListArray[Entry].DataH == Data_A 且 ListArray[Entry].DataL == Data_B 並印出其結果。如果沒有找到的話，印出”no found.”。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void Q3(unsigned int DATA_A, unsigned int DATA_B) { int found_entry = ListHead; int pre_entry = NULL; int next_entry = NULL; while (ListArray[found_entry].NextPtr != NULL) { if (ListArray[found_entry].DataH == DATA_A \u0026amp;\u0026amp; ListArray[found_entry].DataL == DATA_B) { if (pre_entry == NULL) printf(\u0026#34;pre_entry = NULL, found_entry = ListHead\\n\u0026#34;); else printf(\u0026#34;pre_entry = %d, found_entry = %d\u0026#34;, pre_entry, found_entry); printf(\u0026#34;found it\\n\u0026#34;); next_entry = ListArray[found_entry].NextPtr; if (ListArray[next_entry].DataH \u0026lt;\u0026lt; 16 + ListArray[next_entry].DataL \u0026gt; DATA_A \u0026lt;\u0026lt; 16 + DATA_B) break; } pre_entry = found_entry; found_entry = ListArray[found_entry].NextPtr; } } - Sort Quick sort 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #define SWAP(x,y) {int t; t = x; x = y; y = t;} void quickSort(int number[], int left, int right) { if(left \u0026lt; right) { int s = number[(left+right)/2]; int i = left - 1; int j = right + 1; while(1) { while(number[++i] \u0026lt; s) ; // 向右找 while(number[--j] \u0026gt; s) ; // 向左找 if(i \u0026gt;= j) break; SWAP(number[i], number[j]); } quickSort(number, left, i-1); // 對左邊進行遞迴 quickSort(number, j+1, right); // 對右邊進行遞迴 } } - Search Binary serach 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int binsearch(int* arr, int k, int n) { int left = 0, right = n; while (left \u0026lt;= right) { int mid = (left+right)/2; if (arr[mid] \u0026gt; k) { // 往左半部找 right = mid - 1; } else if (arr[mid] \u0026lt; k) { // 往右半部找 left = mid + 1; } else return mid; } return -1; // not found } - Big / Little -Endian 在現今主流的 CPU 中，最常見的位元組順序有兩種，分別是 Big-Endian 與 Little-Endian，Big-Endian 是指資料放進記憶體中的時候，最高位的位元組會放在最低的記憶體位址上，而 Little-Endian 則是剛好相反，它會把最高位的位元組放在最高的記憶體位址上。 不同 type pointer++時，memery address的差別 當你對一個int指針執行pointer++操作時，它會遞增內存地址，遞增的內存地址通常是4或8字節。 當你對一個char指針執行pointer++操作時，它會遞增內存地址，遞增的內存地址通常是1字節。 Copy by value / Call by reference 的意思 Copy by value:當你將參數傳遞給函數時，函數使用參數的副本來執行操作。這意味著在函數內部對參數的任何更改都不會影響原始參數的值。 Call by reference:當你將參數按引用傳遞給函數時，函數可以直接訪問和修改原始參數的值，因為它具有對原始參數內存位置的引用。 Struct / Union / Enum 結構體（struct）用於組織具有不同數據類型的成員變數，每個成員變數占據獨立的內存空間。 聯合體（union）用於組織具有相同起始位置的成員變數，它們共享內存空間。 列舉（enum）用於定義命名常數集合，通常實現為整數值。\n結構體（struct）：\n結構體用於定義一種自定義的數據類型，它可以包含多個不同類型的成員變數（字段），每個成員變數占據自己的內存空間。 結構體的內存布局是成員按照定義的順序依次排列，每個成員變數在內存中占據連續的空間。 結構體的內存大小等於所有成員變數的內存大小之和，沒有內存重疊。 聯合體（union）：\n聯合體也是用於組織數據的構造，但它與結構體不同，它的成員共享相同的內存位置。 聯合體的內存布局是所有成員共享相同的內存空間，占據的空間等於最大成員的大小。 僅能同時使用一個成員變數，改變一個成員的值會影響其他成員。 列舉（enum）：\n列舉用於定義一組命名常數，它們在內存中通常被實現為整數值。 列舉的內存布局通常是整數，它們的值按照聲明的順序遞增，但它們只占據一個整數的內存空間。 OS 解釋multi-thread、multi-process 它們允許程序同時執行多個任務，提高了程序的性能和響應能力。\n多線程通過在單個進程內並發執行多個線程來提高程序性能，線程之間共享相同的內存和資源。 多進程通過在操作系統中並發執行多個獨立的進程來提高程序性能，每個進程有自己的獨立內存和資源。 多線程適用於需要共享數據或共享內存的情況，而多進程適用於需要隔離和保護數據的情況。選擇哪種方式取決於應用程序的需求和性能要求。 題目 最大公因數 1 2 3 4 5 6 7 8 9 int gcd(int x, int y) { // x \u0026gt; y if (y == 0) /* 餘 0，除數 x 即為最大公因數 */ return x; else return gcd(y, x % y); /* 前一步驟的除數為被除數，餘數為除數 */ } - 字串反轉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void swap(char* a, char* b) { char t = *a; *a = *b; *b = t; } void reverseString(char* s, int sSize){ if (s == NULL) return NULL; int j = sSize - 1; for (int i = 0; i \u0026lt; sSize/2; i++) { swap( \u0026amp;s[i], \u0026amp;s[j] ); j--; } } - 給一個unsigned short, 問換算成16進制後四個值是否相同? 若是回傳1,否則回傳0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int isHexEqaul(unsigned short input) { // input = 0xAAAA; unsigned short input; unsigned short hex[4]; // 0xFFFF ==\u0026gt; 0000 0000 0000 0000 int is_eqaul; hex[0] = (input \u0026amp; 0xF000) \u0026gt;\u0026gt; 12; hex[1] = (input \u0026amp; 0x0F00) \u0026gt;\u0026gt; 8; hex[2] = (input \u0026amp; 0x00F0) \u0026gt;\u0026gt; 4; hex[3] = input \u0026amp; 0x000F; is_eqaul = ((hex[0] == hex[1]) \u0026amp;\u0026amp; (hex[1] == hex[2]) \u0026amp;\u0026amp; (hex[2] == hex[3])); return is_eqaul; } - 求一個數的最高位1在第幾位 1 2 3 4 5 6 7 8 9 10 11 12 13 int main(){ unsigned int a = 0x65; // 0110 0101 unsigned int test_bit = 128; // 1000 0000 int count = 7; // sizeof(unsigned int)*8 == 該data type的bit數 while (((a \u0026amp; test_bit) \u0026gt;\u0026gt; count) != 1) { count--; test_bit \u0026gt;\u0026gt;= 1; } printf(\u0026#34;hightest bit is %d th bit\\n\u0026#34;, count); return 0; } - ","date":"2023-10-29T14:17:58+08:00","image":"http://skysora.github.io/post/8/header_hubce42636ecacc1a380b462f3110efcec_37455_120x120_fill_q75_box_smart1.jpg","permalink":"http://skysora.github.io/post/8/","title":"軟韌相關題目"},{"content":"製作網頁的起手式-註冊和登入 結果圖 程式連結\n前置作業 下載 下載docker、docker-compose 下載檔案、執行 前往:8888 1 2 3 4 5 git clone https://github.com/skysora/docker-compose-flask-login cd docker-compose-flask-login docker-compose up - 確認資料夾層級 static資料夾放css、js檔案 templates資料夾放html檔案 auth資料夾放登入註冊相關檔案 其他為設定檔案、啟動檔案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 docker-compose-flask-login/ ├── web/ │ ├── static/ │ │ ├── css/ │ │ │ ├── style.css │ │ │ ├── ... │ │ ├── js/ │ │ │ ├── main.js │ │ │ ├── ... │ ├── templates/ │ │ ├── index.html │ │ ├── login.html │ │ ├── register.html │ │ ├── ... │ ├── auth/ │ │ ├── __init__.py │ │ ├── forms.py │ │ ├── models.py │ │ ├── views.py │ ├── requirements.txt │ ├── gunicorn.conf.py │ ├── config.py │ ├── app.db │ ├── Dockerfile ├── docker-compose.yml └── ... 打包後端服務 使用docker-compose方便一鍵啟動，並且未來若有擴充模組需求會比較方便 以下例子為若未來有需要使用到mysql server docker-compose的寫法，但在本文中不需要db部分所以會註解掉 web 服務需要的套件會寫在./web/Dockerfile中 另外我們使用gunicorn當作部署 Python Web 應用程序的 WSGI HTTP 伺服器，控制檔案寫在./web/gunicorn.conf.py中 docker-compose docker-compose.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 version: \u0026#39;3.0\u0026#39; services: # db: # image: mariadb:10 # container_name: \u0026#39;db\u0026#39; # environment: # - MYSQL_ROOT_PASSWORD=admin # - MYSQL_USER=\u0026#34;root\u0026#34; # - MYSQL_DATABASE:DB # - MYSQL_PASSWORD=admin # ports: # - \u0026#34;5500:3306\u0026#34; # volumes: # - ./sql:/docker-entrypoint-initdb.d # - ./sql:/var/lib/mysql # networks: # - my-network # restart: always app: build: ./web container_name: \u0026#39;web\u0026#39; # depends_on: # - db ports: - 8888:80 volumes: - ./web:/web networks: - my-network restart: always networks: my-network: driver: bridge - Dockerfile ./web/Dockerfile\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 FROM ubuntu:20.04 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y wget apt-transport-https RUN wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb RUN dpkg -i packages-microsoft-prod.deb RUN rm packages-microsoft-prod.deb RUN apt-get update RUN apt-get upgrade -y RUN apt-get install python3.8-distutils -y RUN apt-get install python3.8 -y RUN apt-get install wget -y RUN wget https://bootstrap.pypa.io/get-pip.py RUN python3.8 get-pip.py COPY ./requirements.txt /requirements.txt COPY ./packages/flask-login /packages/flask-login RUN pip3 install -r /requirements.txt RUN pip3 install ./packages/flask-login RUN apt install vim -y WORKDIR /web CMD gunicorn app:app -c gunicorn.conf.py - ./web/gunicorn.conf.py\n1 2 3 4 5 6 workers = 5 worker_class = \u0026#34;gevent\u0026#34; bind = \u0026#34;0.0.0.0:80\u0026#34; - Web router 基本設定 登入註冊相關route設定(view.py) ./web/auth/view.py檔案宣告了所有跟登入註冊相關route 我們將相關route依附在auth_blueprint中，在將auth_blueprint註冊到執行app.py中 ./web/auth/view.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from flask import Blueprint auth_blueprint = Blueprint(\u0026#39;auth\u0026#39;, __name__, template_folder=\u0026#39;templates\u0026#39;) @auth_blueprint.route(\u0026#34;/\u0026#34;) @login_required def init(): ... @auth_blueprint.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): ... @auth_blueprint.route(\u0026#34;/register\u0026#34;,methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def register(): ... @auth_blueprint.route(\u0026#34;/logout\u0026#34;,methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def logout(): ... - app.py ./web/app.py\n1 2 3 4 5 6 7 8 9 10 11 from flask import Flask from config import Config from auth.views import auth_blueprint app = Flask(__name__) app.config.from_object(Config) app.register_blueprint(auth_blueprint) if __name__ == \u0026#34;__main__\u0026#34;: app.run() - 創建DataBase 創建儲存使用者資料的DB，在./web/auth/init.py 中宣告，在註冊到app.py中 基本設定寫在Config中 SQLAlchemy DB ./web/auth/init.py\n1 2 3 4 from flask_sqlalchemy import SQLAlchemy db = SQLAlchemy() - Config ./web/config.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import os from datetime import timedelta basedir = os.path.abspath(os.path.dirname(__file__)) class BaseConfig: # 基本配置 SECRET_KEY = os.environ.get(\u0026#39;key\u0026#39;) PERMANENT_SESSION_LIFETIME = timedelta(days=14) class Config(BaseConfig): # SECRET_KEY SECRET_KEY = os.environ.get(\u0026#39;SECRET_KEY\u0026#39;) or \u0026#39;A-VERY-LONG-SECTRET-KEY\u0026#39; SQLALCHEMY_DATABASE_URI = os.environ.get(\u0026#39;DATABASE_URL\u0026#39;) or \u0026#39;sqlite:///\u0026#39; + os.path.join(basedir,\u0026#39;app.db\u0026#39;) SQLALCHEMY_TRACK_MODIFICATIONS= False - Model 創建使用者資訊到./web/auth/models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from . import db class User(db.Model): id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(20), unique=True, nullable=False) email = db.Column(db.String(120), unique=True,nullable=False) password = db.Column(db.String(20), unique=True, nullable=False) def __repr__(self): return \u0026#39;\u0026lt;User %r\u0026gt;\u0026#39; % self.username - 創建DB指令 在app.py中創建(db.create_all())，注意這裡創建完後要註解。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from flask import Flask from config import Config from auth.views import auth_blueprint app = Flask(__name__) app.config.from_object(Config) app.register_blueprint(auth_blueprint) # init create db with app.app_context(): db.create_all() if __name__ == \u0026#34;__main__\u0026#34;: app.run() - 註冊 註冊表單 創建需要表格到./web/auth/form.py ./web/auth/form.py包含欄位名稱以及驗證 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class RegisterForm(FlaskForm): username = StringField(\u0026#39;Username\u0026#39;,validators = [DataRequired(),Length(min=3,max=20)]) email = StringField(\u0026#39;Email\u0026#39;,validators = [DataRequired(),Email()]) password = PasswordField(\u0026#39;Password\u0026#39;,validators=[DataRequired(),Length(min=8,max=20)]) confirm = PasswordField(\u0026#39;Repeat Password\u0026#39;,validators=[DataRequired(),EqualTo(\u0026#39;password\u0026#39;)]) def validate_username(self,username): user = User.query.filter_by(username=username.data).first() if user: raise ValidationError(\u0026#34;Username already taken,please chosse anthor username\u0026#34;) def validate_email(self,email): user = User.query.filter_by(email=email.data).first() if user: raise ValidationError(\u0026#34;Email already taken,please chosse anthor username\u0026#34;) - 前端對應表單 前端html要對應 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;form method=\u0026#34;POST\u0026#34; action=\u0026#34;{{ url_for(\u0026#39;auth.register\u0026#39;) }}\u0026#34;\u0026gt; {{ form.hidden_tag() }} \u0026lt;!-- 隱藏的 CSRF 欄位 --\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; {{ form.username.label(class=\u0026#34;form-control-label\u0026#34;) }} {{ form.username(class=\u0026#34;form-control\u0026#34;) }} {% for error in form.username.errors %} \u0026lt;span class=\u0026#34;text-danger\u0026#34;\u0026gt;{{ error }}\u0026lt;/span\u0026gt; {% endfor %} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; {{ form.email.label(class=\u0026#34;form-control-label\u0026#34;) }} {{ form.email(class=\u0026#34;form-control\u0026#34;) }} {% for error in form.email.errors %} \u0026lt;span class=\u0026#34;text-danger\u0026#34;\u0026gt;{{ error }}\u0026lt;/span\u0026gt; {% endfor %} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; {{ form.password.label(class=\u0026#34;form-control-label\u0026#34;) }} {{ form.password(class=\u0026#34;form-control\u0026#34;) }} {% for error in form.password.errors %} \u0026lt;span class=\u0026#34;text-danger\u0026#34;\u0026gt;{{ error }}\u0026lt;/span\u0026gt; {% endfor %} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; {{ form.confirm.label(class=\u0026#34;form-control-label\u0026#34;) }} {{ form.confirm(class=\u0026#34;form-control\u0026#34;) }} {% for error in form.confirm.errors %} \u0026lt;span class=\u0026#34;text-danger\u0026#34;\u0026gt;{{ error }}\u0026lt;/span\u0026gt; {% endfor %} \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Register\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; - 後端接收資料處理 flask後端，./web/auth/view.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @auth_blueprint.route(\u0026#34;/register\u0026#34;,methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def register(): if current_user.is_authenticated: return redirect(url_for(\u0026#39;view.azure\u0026#39;)) form = RegisterForm() if form.validate_on_submit(): username = form.username.data email = form.email.data password = bctrypt.generate_password_hash(form.password.data) user = User(username=username,password=password,email=email) db.session.add(user) db.session.commit() flash(\u0026#34;Congrates registeration success\u0026#34;,category=\u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;auth.login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;,form=form) - 登入 註冊表單 創建需要表格到./web/auth/form.py ./web/auth/form.py包含欄位名稱 1 2 3 4 5 6 7 class LoginForm(FlaskForm): username = StringField(\u0026#39;Username\u0026#39;,validators = [DataRequired(),Length(min=3,max=20)]) password = PasswordField(\u0026#39;Password\u0026#39;,validators=[DataRequired(),Length(min=8,max=20)]) remember = BooleanField(\u0026#39;Remember\u0026#39;, default=True) - 前端對應表單 前端html要對應 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;form method=\u0026#34;POST\u0026#34; action=\u0026#34;{{ url_for(\u0026#39;auth.login\u0026#39;) }}\u0026#34;\u0026gt; {{ form.hidden_tag() }} \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; {{ form.username(class=\u0026#34;form-control\u0026#34;, placeholder=\u0026#34;Enter your username\u0026#34;) }} {% for error in form.username.errors %} \u0026lt;span class=\u0026#34;text-danger\u0026#34;\u0026gt;{{ error }}\u0026lt;/span\u0026gt; {% endfor %} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; {{ form.password(class=\u0026#34;form-control\u0026#34;, placeholder=\u0026#34;Enter your password\u0026#34;) }} {% for error in form.password.errors %} \u0026lt;span class=\u0026#34;text-danger\u0026#34;\u0026gt;{{ error }}\u0026lt;/span\u0026gt; {% endfor %} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-check\u0026#34;\u0026gt; {{ form.remember(class=\u0026#34;form-check-input\u0026#34;) }} \u0026lt;label class=\u0026#34;form-check-label\u0026#34; for=\u0026#34;remember\u0026#34;\u0026gt;Remember me\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; - 後端接收資料處理 flask後端，./web/auth/view.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @auth_blueprint.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if current_user.is_authenticated: return redirect(url_for(\u0026#39;view.azure\u0026#39;)) form = LoginForm() if form.validate_on_submit(): username = form.username.data password = form.password.data remember = form.remember.data user = User.query.filter_by(username=username).first() if user and bctrypt.check_password_hash(user.password,password): # User exists and password matched login_user(user,remember=remember) flash(\u0026#39;Login success\u0026#39;,category=\u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;auth.init\u0026#39;)) flash(\u0026#39;User not exists or password not match\u0026#39;,category=\u0026#39;danger\u0026#39;) return render_template(\u0026#39;sign-in.html\u0026#39;,form=form) - 登出 ./web/auth/view.py，建立登出 1 2 3 4 5 6 7 @auth_blueprint.route(\u0026#34;/logout\u0026#34;,methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def logout(): logout_user() flash(\u0026#39;Logged out successfully\u0026#39;, category=\u0026#39;info\u0026#39;) return redirect(url_for(\u0026#39;auth.init\u0026#39;)) - ","date":"2023-10-17T09:42:42+08:00","image":"http://skysora.github.io/post/7/header_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"http://skysora.github.io/post/7/","title":"[Flask]利用docker-compose一鍵啟動網頁服務，製作網頁的起手式-註冊和登入"},{"content":"利用OpenCV計算食物份量(簡單版) 結果圖 流程 讀圖 1 2 3 4 string path = \u0026#34;Resources/12779.jpg\u0026#34;; Mat img = imread(path); - 將圖片模糊化(GaussianBlur) 1 2 3 4 5 // Preprocessing cvtColor(img, imgGray,COLOR_BGR2GRAY); GaussianBlur(img, imgBlur, Size(11,11), 3,0); - 利用Canny演算法找邊緣 1 2 3 Canny(imgBlur, imgCanny, 50, 100); - 填補空洞(Dilate) 1 2 3 4 Mat kernel = getStructuringElement(MORPH_RECT, Size(3,3)); dilate(imgCanny, imgDil, kernel); - 找邊緣點(findContours)-\u0026gt;計算面積 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //得到輪廓 void getContours(Mat imgDil , Mat img){ vector\u0026lt;vector\u0026lt;Point\u0026gt;\u0026gt; contours; vector\u0026lt;Vec4i\u0026gt; hierarchy; //找輪廓點 findContours(imgDil,contours,hierarchy,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE); string objectType; for (int i = 0; i\u0026lt;contours.size();i++){ int area = contourArea(contours[i]); vector\u0026lt;vector\u0026lt;Point\u0026gt;\u0026gt; conPoly(contours.size()); vector\u0026lt;Rect\u0026gt; boundRect(contours.size()); if(area\u0026gt;1000){ // arcLength 函數通常用於計算輪廓的周長或曲線的長度。第二個參數 true 表示該輪廓是封閉的 float peri = arcLength(contours[i], true); // 這一行code使用多邊形逼近方法對輪廓進行逼近;0.0001*peri：逼近的精度參數，它是相對於輪廓周長的百分比。輪廓周長的2%用於確定逼近的精度。這個值越小，逼近的多邊形就越接近原始輪廓。 approxPolyDP(contours[i], conPoly[i], 0.0001*peri, true); drawContours(img, conPoly, i, Scalar(255,0,255),2); // 畫正方形方匡 boundRect[i] = boundingRect(conPoly[i]); rectangle(img, boundRect[i].tl(), boundRect[i].br(),Scalar(0,255,0),1); } } } - Total Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 Mat imgGray,imgBlur,imgCanny,imgDil,imgErode; //得到輪廓 void getContours(Mat imgDil , Mat img){ vector\u0026lt;vector\u0026lt;Point\u0026gt;\u0026gt; contours; vector\u0026lt;Vec4i\u0026gt; hierarchy; //找輪廓點 findContours(imgDil,contours,hierarchy,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE); string objectType; for (int i = 0; i\u0026lt;contours.size();i++){ int area = contourArea(contours[i]); vector\u0026lt;vector\u0026lt;Point\u0026gt;\u0026gt; conPoly(contours.size()); vector\u0026lt;Rect\u0026gt; boundRect(contours.size()); if(area\u0026gt;1000){ // arcLength 函數通常用於計算輪廓的周長或曲線的長度。第二個參數 true 表示該輪廓是封閉的 float peri = arcLength(contours[i], true); // 這一行code使用多邊形逼近方法對輪廓進行逼近;0.0001*peri：逼近的精度參數，它是相對於輪廓周長的百分比。輪廓周長的2%用於確定逼近的精度。這個值越小，逼近的多邊形就越接近原始輪廓。 approxPolyDP(contours[i], conPoly[i], 0.0001*peri, true); drawContours(img, conPoly, i, Scalar(255,0,255),2); // 畫正方形方匡 boundRect[i] = boundingRect(conPoly[i]); rectangle(img, boundRect[i].tl(), boundRect[i].br(),Scalar(0,255,0),1); } } } int main() { string path = \u0026#34;Resources/12779.jpg\u0026#34;; Mat img = imread(path); // Preprocessing cvtColor(img, imgGray,COLOR_BGR2GRAY); GaussianBlur(img, imgBlur, Size(11,11), 3,0); Canny(imgBlur, imgCanny, 50, 100); Mat kernel = getStructuringElement(MORPH_RECT, Size(3,3)); dilate(imgCanny, imgDil, kernel); getContours(imgDil,img); imshow(\u0026#34;Image\u0026#34;, img); waitKey(0); return 0; } - 取得份量 得到面積後，使用swift ARKit技術可以得到相機到桌面距離(到平面距離)，依照公式求得物件體積。 影片解說 詳細說明可以看以下影片，但其中物件偵測是使用Yolo模型判定。 ","date":"2023-10-09T21:18:23+08:00","image":"http://skysora.github.io/post/6/header_hudd2e8259c20ed0dcaa856c253552e90f_14625_120x120_fill_q75_box_smart1.jpg","permalink":"http://skysora.github.io/post/6/","title":"利用OpenCV計算食物份量(簡單版)"},{"content":"利用Canva製作旅遊手冊 模板連結\n結果圖(更多請至模板連結看) 開頭 第一頁顯示每一天的重要斷點位置 內容 票卷QRCode可以貼好，方便換車票 相關景點的Blog利用QRcode產生器產生QRcode 若有預約餐廳或者住宿，事先準備好導航QRcode，不用現場查詢，若旅伴失散也能各自找到地點 每個景點的描述、去的方法都可以詳細紀錄 ","date":"2023-10-08T00:00:00Z","image":"http://skysora.github.io/post/5/header_hubce42636ecacc1a380b462f3110efcec_37455_120x120_fill_q75_box_smart1.jpg","permalink":"http://skysora.github.io/post/5/","title":"利用Canva製作旅遊手冊(提供模板)"},{"content":"結果 架構 建置步驟 下載需要的檔案，並啟動 1 2 3 4 git clone https://github.com/skysora/multi-server-resource-management.git cd multi-server-resource-management docker-compose up -d 建立DataScoure meau-\u0026gt;Connections-\u0026gt;Data sources-\u0026gt;Add new data source-\u0026gt;prometheus 在Prometheus server URL，輸入\u0026lt;你的url\u0026gt;:9090 Save \u0026amp; test 若有多台主機要重複此步驟，並且每台主機都要經過第一步驟。 建立Dashboard 可依照喜好和使用的模組到https://grafana.com/grafana/dashboards/選擇喜歡的dashboards 本教學使用三個模組分別為node_exporter、cadvisor、nvidia_gpu_exporter node_exporter蒐集server基本資源，Ex：CPU、Memory、Network。參考模板：https://grafana.com/grafana/dashboards/1860-node-exporter-full/ cadvisor 蒐集 docker容器內資源用量。參考模板：https://grafana.com/grafana/dashboards/14282-cadvisor-exporter/ nvidia_gpu_exporter蒐集server GPU使用量。參考模板：https://grafana.com/grafana/dashboards/14574-nvidia-gpu-metrics/ 進入模板頁面copy dashboard ID Meau-\u0026gt;Dashboards-\u0026gt;New-\u0026gt;Import 將ID 放入UID中，點選Load(Load之後會顯示另外一個ID) Prometheus(DataScoure)選擇資料來源 點擊Import 依照步驟2完成所有監控設定 ","date":"2023-09-28T15:02:14+08:00","image":"http://skysora.github.io/post/4/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"http://skysora.github.io/post/4/","title":"Multi-server Resource Management"},{"content":" 結論 功能 Azure GCP AWS Vocol 服務名稱 Speech Cloud Speech-to-Text API Amazon Transcribe vovol.ai GUI介面 X O O O 輸出多元度 高 普 普 低 切割單位 整段、句子 句子、字 整段、詞 說話者 調整設定 無 普 最多 少 Azure 優點：回傳的比較詳細 缺點：沒有GUI介面，要自己刻 可以簡單利用API串接的方式達到即時麥克風輸入、語音上傳的功能，但是如果要進行較大檔案的上傳，利用官方網站提供的Sample code無法執行，要另外自行串接 輸出格式：大致如下，combinedRecognizedPhrases為辨識出的每個句子組合的文章，recognizedPhrases則包含每個辨識出來的句子詳細資料。 1 2 3 4 5 6 7 8 9 { \u0026#34;source\u0026#34;:\u0026#34;https://ntuststorage1.blob.core.windows.net/test/1.wav\u0026#34;, \u0026#34;timestamp\u0026#34;:\u0026#34;2023-09-18T14:06:32Z\u0026#34;, \u0026#34;durationInTicks\u0026#34;:6875900000, \u0026#34;duration\u0026#34;:\u0026#34;PT11M27.59S\u0026#34;, \u0026#34;combinedRecognizedPhrases\u0026#34;:[...], \u0026#34;recognizedPhrases\u0026#34;[...], } Property Description Lexical The lexical form of the recognized text: the actual words recognized. ITN The inverse-text-normalized (ITN) or canonical form of the recognized text, with phone numbers, numbers, abbreviations (\u0026ldquo;doctor smith\u0026rdquo; to \u0026ldquo;dr smith\u0026rdquo;), and other transformations applied. MaskedITN The ITN form with profanity masking applied, if requested. Display The display form of the recognized text, with punctuation and capitalization added. This parameter is the same as what DisplayText provides when the format is set to simple. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026#34;combinedRecognizedPhrases\u0026#34;:[ { \u0026#34;channel\u0026#34;:0, \u0026#34;lexical\u0026#34;:\u0026#34;台 湾 民 主 国 的 抗 日 这 是 什 么 呢 蓝 色 的 底 色 黄 色 的 老 虎 蓝 地 黄 虎 旗 是 什 么 国 家 的 旗 帜 台 湾 民 主 国 台 湾 民 主 国 蓝 地 黄 虎 旗 与 清 朝 黄 龙 起 有 何 不 同 呢 颜 色 相 反 龙 虎 相 斗 还 是 龙 兄 虎 弟 台 湾 民 主 国 什 么 时 候 成 立 的 呢 目 的 是 什 么 总 统 是 谁 结 果 又 如 何 呢 西 元 一 八 九 四 年 中 国 清 廷 与 日 本 因 为 朝 鲜 问 题 爆 发 什 么 战 争 西 元 一 八 九 四 年 清 光 绪 二 十 年 中 国 清 廷 与 日 本 \u0026#34;, \u0026#34;itn\u0026#34;:\u0026#34;台 湾 民 主 国 的 抗 日 这 是 什 么 呢 蓝 色 的 底 色 黄 色 的 老 虎 蓝 地 黄 虎 旗 是 什 么 国 家 的 旗 帜 台 湾 民 主 国 台 湾 民 主 国 蓝 地 黄 虎 旗 与 清 朝 黄 龙 起 有 何 不 同 呢 颜 色 相 反 龙 虎 相 斗 还 是 龙 兄 虎 弟 台 湾 民 主 国 什 么 时 候 成 立 的 呢 目 的 是 什 么 总 统 是 谁 结 果 又 如 何 呢 西 元 1894年 中 国 清 廷 与 日 本 因 为 朝 鲜 问 题 爆 发 什 么 战 争 西 元 1894年 清 光 绪 二十 年 中 国 清 廷 与 日 本 因 为 朝 鲜 问 题 爆 发 甲 午\u0026#34;, \u0026#34;maskedITN\u0026#34;:\u0026#34;台湾民主国的抗日这是什么呢蓝色的底色黄色的老虎蓝地黄虎旗是什么国家的旗帜台湾民主国台湾民主国蓝地黄虎旗 关甲午战争西元1895年6月日军进入哪里就宣布开始统治台湾 台北\u0026#34;, \u0026#34;display\u0026#34;:\u0026#34;台湾民主国的抗日，这是什么呢？蓝色的底色，黄色的老虎蓝地黄虎旗是什么国家的旗帜？台湾民主国台湾民主国蓝地黄虎旗。 与清朝黄龙起有何不同呢？颜色相反，龙虎相斗，还是龙兄虎弟，台湾民主国什么时候成立的呢？目的是什么？总统是谁？结果又如何呢？ 西元1894年，中国清廷与日本因为朝鲜问题爆发什么战争？西元1894年清光绪二十年，中国清廷与日本因为朝鲜问题爆发甲午战争，中国的海战陆战都。 都失败，所以清廷派李鸿章到日本求和在下关也就是马关的谈判当\u0026#34; }, { \u0026#34;channel\u0026#34;:1, \u0026#34;lexical\u0026#34;:\u0026#34;台 湾 民 主 国 的 抗 日 这 是 什 么 呢 蓝 色 的 底 色 黄 色 的 老 虎 蓝 地 黄 虎 旗 是 什 么 国 家 的 旗 帜 台 湾 民 主 国 台 湾 民 主 国 蓝 地 黄 虎 旗 与 清 朝 黄 龙 起 有 何 不 同 呢 颜 色 相 反 龙 虎 相 斗 还 是 龙 生 虎 地 台 湾 民 主 国 什 么 时 候 成 立 的 呢 目...\u0026#34;, \u0026#34;itn\u0026#34;:\u0026#34;台 湾 民 主 国 的 抗 日 这 是 什 么 呢 蓝 色 的 底 色 黄 色 的 老 虎 蓝 地 黄 虎 旗 是...\u0026#34;, \u0026#34;maskedITN\u0026#34;:\u0026#34;台湾民主国的抗日这是什么呢...\u0026#34;, \u0026#34;display\u0026#34;:\u0026#34;台湾民主国的抗日，...\u0026#34; } ], 這裡是回傳5-best Property Description Confidence The confidence score of the entry, from 0.0 (no confidence) to 1.0 (full confidence). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026#34;recognizedPhrases\u0026#34;:[ { \u0026#34;recognitionStatus\u0026#34;:\u0026#34;Success\u0026#34;, \u0026#34;channel\u0026#34;:0, \u0026#34;offset\u0026#34;:\u0026#34;PT0.64S\u0026#34;, \u0026#34;duration\u0026#34;:\u0026#34;PT28.04S\u0026#34;, \u0026#34;offsetInTicks\u0026#34;:6400000.0, \u0026#34;durationInTicks\u0026#34;:280400000.0, \u0026#34;nBest\u0026#34;:[ { \u0026#34;confidence\u0026#34;:0.8839353, \u0026#34;lexical\u0026#34;:\u0026#34;台 湾 民 主 国 的 抗 日 这 是 什 么 呢 蓝 色 的 底 色 黄 色 的 老 虎 蓝 地 黄 虎 旗 是 什 么 国 家 的 旗 帜 台 湾 民 主 国 台 湾 民 主 国 蓝 地 黄 虎 旗\u0026#34;, \u0026#34;itn\u0026#34;:\u0026#34;台 湾 民 主 国 的 抗 日 这 是 什 么 呢 蓝 色 的 底 色 黄 色 的 老 虎 蓝 地 黄 虎 旗 是 什 么 国 家 的 旗 帜 台 湾 民 主 国 台 湾 民 主 国 蓝 地 黄 虎 旗\u0026#34;, \u0026#34;maskedITN\u0026#34;:\u0026#34;台湾民主国的抗日这是什么呢蓝色的底色黄色的老虎蓝地黄虎旗是什么国家的旗帜台湾民主国台湾民主国蓝地黄虎旗\u0026#34;, \u0026#34;display\u0026#34;:\u0026#34;台湾民主国的抗日，这是什么呢？蓝色的底色，黄色的老虎蓝地黄虎旗是什么国家的旗帜？台湾民主国台湾民主国蓝地黄虎旗。\u0026#34; }, { \u0026#34;confidence\u0026#34;:0.8823599, \u0026#34;lexical\u0026#34;:\u0026#34;台湾民主国的抗日这是什么呢蓝色的底色黄色的老虎蓝帝黄虎旗是什么国家的旗帜台湾民主国台湾民主国蓝帝黄虎旗\u0026#34;, \u0026#34;itn\u0026#34;:\u0026#34;台湾民主国的抗日这是什么呢蓝色的底色黄色的老虎蓝帝黄虎旗是什么国家的旗帜台湾民主国台湾民主国蓝帝黄虎旗\u0026#34;, \u0026#34;maskedITN\u0026#34;:\u0026#34;台湾民主国的抗日这是什么呢蓝色的底色黄色的老虎蓝帝黄虎旗是什么国家的旗帜台湾民主国台湾民主国蓝帝黄虎旗\u0026#34;, \u0026#34;display\u0026#34;:\u0026#34;台湾民主国的抗日这是什么呢蓝色的底色黄色的老虎蓝帝黄虎旗是什么国家的旗帜台湾民主国台湾民主国蓝帝黄虎旗\u0026#34; } ] }, { \u0026#34;recognitionStatus\u0026#34;:\u0026#34;Success\u0026#34;, \u0026#34;channel\u0026#34;:0, \u0026#34;offset\u0026#34;:\u0026#34;PT29.52S\u0026#34;, \u0026#34;duration\u0026#34;:\u0026#34;PT29.2S\u0026#34;, \u0026#34;offsetInTicks\u0026#34;:295200000.0, \u0026#34;durationInTicks\u0026#34;:292000000.0, \u0026#34;nBest\u0026#34;:[ { \u0026#34;confidence\u0026#34;:0.8856299, \u0026#34;lexical\u0026#34;:\u0026#34;与 清 朝 黄 龙 起 有 何 不 同 呢 颜 色 相 反 龙 虎 相 斗 还 是 龙 兄 虎 弟 台 湾 民 主 国 什 么 时 候 成 立 的 呢 目 的 是 什 么 总 统 是 谁 结 果 又 如 何 呢\u0026#34;, \u0026#34;itn\u0026#34;:\u0026#34;与 清 朝 黄 龙 起 有 何 不 同 呢 颜 色 相 反 龙 虎 相 斗 还 是 龙 兄 虎 弟 台 湾 民 主 国 什 么 时 候 成 立 的 呢 目 的 是 什 么 总 统 是 谁 结 果 又 如 何 呢\u0026#34;, \u0026#34;maskedITN\u0026#34;:\u0026#34;与清朝黄龙起有何不同呢颜色相反龙虎相斗还是龙兄虎弟台湾民主国什么时候成立的呢目的是什么总统是谁结果又如何呢\u0026#34;, \u0026#34;display\u0026#34;:\u0026#34;与清朝黄龙起有何不同呢？颜色相反，龙虎相斗，还是龙兄虎弟，台湾民主国什么时候成立的呢？目的是什么？总统是谁？结果又如何呢？\u0026#34; }, { \u0026#34;confidence\u0026#34;:0.8887188, \u0026#34;lexical\u0026#34;:\u0026#34;与清朝黄龙起有何不同呢颜色相反龙虎相斗还是龙生虎地台湾民主国什么时候成立的呢目的是什么总统是谁结果又如何呢\u0026#34;, \u0026#34;itn\u0026#34;:\u0026#34;与清朝黄龙起有何不同呢颜色相反龙虎相斗还是龙生虎地台湾民主国什么时候成立的呢目的是什么总统是谁结果又如何呢\u0026#34;, \u0026#34;maskedITN\u0026#34;:\u0026#34;与清朝黄龙起有何不同呢颜色相反龙虎相斗还是龙生虎地台湾民主国什么时候成立的呢目的是什么总统是谁结果又如何呢\u0026#34;, \u0026#34;display\u0026#34;:\u0026#34;与清朝黄龙起有何不同呢颜色相反龙虎相斗还是龙生虎地台湾民主国什么时候成立的呢目的是什么总统是谁结果又如何呢\u0026#34; }, ] }, ] GCP 優點：有GUI可以對每個設定做調整，如果沒有要接API比較方便 缺點：輸出feature比較少 輸出格式：會自行判斷斷點，以alternatives做區隔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026#34;results\u0026#34;:[ { \u0026#34;alternatives\u0026#34;:[ { \u0026#34;transcript\u0026#34;:\u0026#34; 台 灣 民 主 國 的 抗 議 , 這 是 什 麼 呢 ? 藍 色 的 底 色 , 黃 色 的 老 虎 , 藍 弟 皇 虎 旗 是 什 麼 國 家 的 期 制 ? 台 灣 民 主 國 , 台 灣 民 主 國 南 地 荒 虎 起 , 與 ,\u0026#34;, \u0026#34;words\u0026#34;:[ { \u0026#34;word\u0026#34;:\u0026#34;台\u0026#34; }, { \u0026#34;word\u0026#34;:\u0026#34;灣\u0026#34; }, ... ] } ], \u0026#34;channelTag\u0026#34;:1, \u0026#34;languageCode\u0026#34;:\u0026#34;zh-TW\u0026#34; }, { \u0026#34;alternatives\u0026#34;:[ { \u0026#34;transcript\u0026#34;:清 草 黃 龍 起 , 有 何 不 同 呢 ? 顏 色 相 反 。 龍 虎 相 鬥 , 還 是 龍 松 虎 地 ? 台 灣 民 主 國 , 什 麼 時 候 成 立 的 呢 ? 目 的 是 什 麼 ? 總 統 是 誰 ? 結 果 又 如 何 呢 ?\u0026#34;, \u0026#34;words\u0026#34;:[ { \u0026#34;word\u0026#34;:\u0026#34;清\u0026#34; }, { \u0026#34;word\u0026#34;:\u0026#34;草\u0026#34; }, ... ] } ], \u0026#34;channelTag\u0026#34;:1, \u0026#34;languageCode\u0026#34;:\u0026#34;zh-TW\u0026#34; }, ] AWS 優點：有GUI可以對每個設定做調整，如果沒有要接API比較方便 缺點：輸出feature比較少 輸出格式：會自行判斷\u0026quot;詞\u0026quot;，給予信心程度、開始結束時間 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 { \u0026#34;jobName\u0026#34;:\u0026#34;2\u0026#34;, \u0026#34;accountId\u0026#34;:\u0026#34;794015217967\u0026#34;, \u0026#34;results\u0026#34;:{ \u0026#34;transcripts\u0026#34;:[ { \u0026#34;transcript\u0026#34;:\u0026#34;臺灣民主國的抗日，這是什麼呢？藍色的底色，黃色的老虎男的黃呼氣是什麼國家的體製臺灣民主國臺灣民主國藍的歡呼，其與清朝黃隆起有何不衕呢？顏色相反龍虎相鬥還是隆胸唬的臺灣民主國什麼時候成立的呢？目的是什麼？總統是誰，結果又如何呢？西元一八九四年中國清廷與日本因為朝鮮問題爆發什麼戰爭？西元一八九四年清光緒二十年中國青年與日本因為朝鮮問題爆髮甲午戰爭，中國的海戰、陸戰都失敗，所以輕盈派的紅妝到日本求和再下官也就是馬觀的談判噹中。日方代錶伊籐薄為予取予求，李鴻章沒有太多討價還價的餘地簽訂了割地賠款的馬關條約日本穫利豐富。...\u0026#34; } ], \u0026#34;items\u0026#34;:[ { \u0026#34;start_time\u0026#34;:\u0026#34;0.65\u0026#34;, \u0026#34;end_time\u0026#34;:\u0026#34;1.05\u0026#34;, \u0026#34;alternatives\u0026#34;:[ { \u0026#34;confidence\u0026#34;:\u0026#34;0.9259\u0026#34;, \u0026#34;content\u0026#34;:\u0026#34;臺\u0026#34; } ], \u0026#34;type\u0026#34;:\u0026#34;pronunciation\u0026#34; }, { \u0026#34;start_time\u0026#34;:\u0026#34;1.05\u0026#34;, \u0026#34;end_time\u0026#34;:\u0026#34;1.42\u0026#34;, \u0026#34;alternatives\u0026#34;:[ { \u0026#34;confidence\u0026#34;:\u0026#34;0.9472\u0026#34;, \u0026#34;content\u0026#34;:\u0026#34;灣\u0026#34; } ], \u0026#34;type\u0026#34;:\u0026#34;pronunciation\u0026#34; }, { \u0026#34;start_time\u0026#34;:\u0026#34;1.42\u0026#34;, \u0026#34;end_time\u0026#34;:\u0026#34;2.02\u0026#34;, \u0026#34;alternatives\u0026#34;:[ { \u0026#34;confidence\u0026#34;:\u0026#34;0.989\u0026#34;, \u0026#34;content\u0026#34;:\u0026#34;民主\u0026#34; } ], \u0026#34;type\u0026#34;:\u0026#34;pronunciation\u0026#34; }, { \u0026#34;start_time\u0026#34;:\u0026#34;2.02\u0026#34;, \u0026#34;end_time\u0026#34;:\u0026#34;2.4\u0026#34;, \u0026#34;alternatives\u0026#34;:[ { \u0026#34;confidence\u0026#34;:\u0026#34;0.5566\u0026#34;, \u0026#34;content\u0026#34;:\u0026#34;國的\u0026#34; } ], \u0026#34;type\u0026#34;:\u0026#34;pronunciation\u0026#34; },... ] }, \u0026#34;status\u0026#34;:\u0026#34;COMPLETED\u0026#34; } Vocol 優點：GUI完整。 缺點：可調整設定很少、沒有API可供使用 輸出格式：以句子做斷點。 1 2 3 4 5 6 7 8 9 10 speaker1: 臺灣民主國的抗日。這... speaker2: 日軍攻佔澎湖。這... speaker1: 西元1895年已未年。5月29日，日軍由北百川功能九親王... speaker2: 中國。清朝統治臺灣。有多少年呢?... speaker1: 臺灣民主國雖然號稱民主，但它是否是一個民主國家呢?不是的... ","date":"2023-09-24T14:21:33+08:00","image":"http://skysora.github.io/post/3/1_hudd2e8259c20ed0dcaa856c253552e90f_14625_120x120_fill_q75_box_smart1.jpg","permalink":"http://skysora.github.io/post/3/","title":"比較各大SpeechRecognizer服務"},{"content":" Batch Normalization 和一般 Normalization 差別 Google 於 2015 年提出了 Batch Normalization 的方法，和輸入數據先做 feature scaling 再進行網路訓練的方法類似。在輸入數據時，通常都會先將 feature 做 normalize 後再進行訓練，可以加速模型收斂；而 Batch Normalization 就是指在每一層輸入都做一次 normalize\nBatch Normalization 的作法就是對每一個 mini-batch 都進行正規化到平均值為0、標準差為1的常態分佈，如此一來可以將分散的數據統一，有助於減緩梯度消失以及解決 Internal Covariate Shift 的問題，同時可以加速收斂，並且有正則化的效果 (可以不使用Dropout)\n多的請參考：https://medium.com/ching-i/batch-normalization-%E4%BB%8B%E7%B4%B9-135a24928f12\nBatchNormalization与LayerNormalization的區別 Batch Normalization 的處理對像是對一批樣本， Layer Normalization 的處理對像是單一樣本。 Batch Normalization 是對這批樣本的同一維度特徵做歸一化， Layer Normalization 是對這單一樣本的所有維度特徵做歸一化。 Optimizer 在影像上和NLP上使用的差別 https://medium.com/programming-with-data/34-%E8%AA%BF%E5%8F%83%E7%89%88bert%E6%87%89%E7%94%A8%E7%AF%84%E4%BE%8B-328f56308e64 selfAttention 為什麼要除一個Scale https://zhuanlan.zhihu.com/p/503321685 Activation function https://medium.com/%E6%B7%B1%E6%80%9D%E5%BF%83%E6%80%9D/ml08-activation-function-%E6%98%AF%E4%BB%80%E9%BA%BC-15ec78fa1ce4 影像 segmentation https://medium.com/ching-i/%E5%BD%B1%E5%83%8F%E5%88%86%E5%89%B2-image-segmentation-%E8%AA%9E%E7%BE%A9%E5%88%86%E5%89%B2-semantic-segmentation-1-53a1dde9ed92 梯度消失梯度爆炸 https://zhuanlan.zhihu.com/p/33006526 梯度消失梯度不只在RNN會發生 https://ithelp.ithome.com.tw/m/articles/10280019 LayerNormalization 通常放在哪裡 為什麼 https://hackmd.io/@CZ-Chuang/BJ39oZnvD ","date":"2023-09-22T00:00:00Z","image":"http://skysora.github.io/post/2/2_hubce42636ecacc1a380b462f3110efcec_37455_120x120_fill_q75_box_smart1.jpg","permalink":"http://skysora.github.io/post/2/","title":"機器學習面試題目"},{"content":"利用Hugo建置靜態網頁放置在Github server上 結果圖 事前軟體安裝 Git Hugo 開始 在Github上創立兩個Repositories 兩個Repositories分別代表\n[YourwebName] : 放置Hugo code [GithubUserName].github.io: 放置Hugo產生出來的靜態網頁 將兩個Repositories clone 下來並初始化hugo folder 1 2 3 4 5 git clone https://github.com/skysora/myweb.git cd myweb hugo new site [yourNeedName] git clone https://github.com/skysora/skysora.github.io.git 將想要的模板git clone 到 /themes目錄下 可以去官方網站挑模板\n1 2 3 4 cd themes git clone https://github.com/CaiJimmy/hugo-theme-stack-starter 注意，若要載hugo-theme-stack-starter模組要另外載mod 1 2 3 4 hugo mod get -u github.com/CaiJimmy/hugo-theme-stack/v3 hugo mod tidy 將hugo.toml 設定檔案做修正 修正baseURL 為你的github網址(baseURL) 將theme修正為你clone模板名稱(theme) import 模組 產生靜態網頁 先將[GithubUserName].github.io Repositories clone 進[yourNeedName] 資料夾 將hugo code 轉成靜態網頁 1 2 3 4 git submodule add -b main https://github.com/skysora/skysora.github.io.git public hugo -t hugo-theme-stack 將靜態網頁部署上去 1 2 3 4 5 cd public git add -A git commit -m \u0026#34;first commit\u0026#34; — Creating a Blog with Hugo and Github in 10 minutes1\nhttps://www.youtube.com/watch?v=LIFvgrRxdt4\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-21T00:00:00Z","image":"http://skysora.github.io/post/1/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"http://skysora.github.io/post/1/","title":"[Web] Hugo+Github server"}]